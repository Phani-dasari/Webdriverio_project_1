import type { Mac2Driver } from '../driver';
import type { AppiumLogger, StringRecord } from '@appium/types';
import type EventEmitter from 'node:events';
export declare class NativeVideoChunksBroadcaster {
    private _ee;
    private _log;
    private _publishers;
    private _terminated;
    constructor(ee: EventEmitter, log: AppiumLogger);
    get hasPublishers(): boolean;
    schedule(uuid: string): void;
    waitFor(uuid: string): Promise<void>;
    shutdown(timeoutMs: number): Promise<void>;
    private _createPublisher;
    private _wait;
    private _cleanup;
}
/**
 * Initiates a new native screen recording session via XCTest.
 * If the screen recording is already running then this call results in noop.
 * A screen recording is running until a testing session is finished.
 * If a recording has never been stopped explicitly during a test session
 * then it would be stopped automatically upon test session termination,
 * and leftover videos would be deleted as well.
 *
 * @since Xcode 15
 * @param fps Frame Per Second setting for the resulting screen recording. 24 by default.
 * @param codec Possible codec value, where `0` means H264 (the default setting), `1` means HEVC
 * @param displayId Valid display identifier to record the video from. Main display is assumed
 * by default.
 * @returns The information about the asynchronously running video recording.
 */
export declare function macosStartNativeScreenRecording(this: Mac2Driver, fps?: number, codec?: number, displayId?: number): Promise<ActiveVideoInfo>;
/**
 * @since Xcode 15
 * @returns The information about the asynchronously running video recording or
 * null if no native video recording has been started.
 */
export declare function macosGetNativeScreenRecordingInfo(this: Mac2Driver): Promise<ActiveVideoInfo | null>;
/**
 * Stops native screen recordind.
 * If no screen recording has been started before then the method throws an exception.
 *
 * @since Xcode 15
 * @param remotePath The path to the remote location, where the resulting video should be uploaded.
 *                              The following protocols are supported: http/https, ftp.
 *                              Null or empty string value (the default setting) means the content of resulting
 *                              file should be encoded as Base64 and passed as the endpoint response value.
 *                              An exception will be thrown if the generated media file is too big to
 *                              fit into the available process memory.
 * @param user The name of the user for the remote authentication.
 * @param pass The password for the remote authentication.
 * @param method The http multipart upload method name. The 'PUT' one is used by default.
 * @param headers  Additional headers mapping for multipart http(s) uploads
 * @param fileFieldName The name of the form field, where the file content BLOB should
 *                                 be stored for http(s) uploads
 * @param formFields Additional form fields for multipart http(s) uploads
 * @param ignorePayload Whether to ignore the resulting video payload
 * and return an empty string. Useful if you prefer to fetch
 * video chunks via a BiDi web socket.
 * @returns Base64-encoded content of the recorded media file if 'remotePath'
 * parameter is falsy or an empty string or ignorePayload is set to `true`.
 * @throws {Error} If there was an error while getting the name of a media file
 * or the file content cannot be uploaded to the remote location
 * or screen recording is not supported on the device under test.
 */
export declare function macosStopNativeScreenRecording(this: Mac2Driver, remotePath?: string, user?: string, pass?: string, method?: string, headers?: StringRecord | [string, any][], fileFieldName?: string, formFields?: StringRecord | [string, string][], ignorePayload?: boolean): Promise<string>;
/**
 * Fetches information about available displays
 *
 * @returns A map where keys are display identifiers and values are display infos
 */
export declare function macosListDisplays(this: Mac2Driver): Promise<StringRecord<DisplayInfo>>;
interface ActiveVideoInfo {
    fps: number;
    codec: number;
    displayId: number;
    uuid: string;
    startedAt: number;
}
interface DisplayInfo {
    id: number;
    isMain: boolean;
}
export {};
//# sourceMappingURL=native-record-screen.d.ts.map