"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Mac2Driver = void 0;
const lodash_1 = __importDefault(require("lodash"));
const driver_1 = require("appium/driver");
const wda_mac_1 = __importDefault(require("./wda-mac"));
const desired_caps_1 = require("./desired-caps");
const appManagemenetCommands = __importStar(require("./commands/app-management"));
const appleScriptCommands = __importStar(require("./commands/applescript"));
const executeCommands = __importStar(require("./commands/execute"));
const findCommands = __importStar(require("./commands/find"));
const gesturesCommands = __importStar(require("./commands/gestures"));
const navigationCommands = __importStar(require("./commands/navigation"));
const recordScreenCommands = __importStar(require("./commands/record-screen"));
const screenshotCommands = __importStar(require("./commands/screenshots"));
const sourceCommands = __importStar(require("./commands/source"));
const logger_1 = __importDefault(require("./logger"));
const method_map_1 = require("./method-map");
const execute_method_map_1 = require("./execute-method-map");
const nativeScreenRecordingCommands = __importStar(require("./commands/native-record-screen"));
/** @type {import('@appium/types').RouteMatcher[]} */
const NO_PROXY = [
    ['GET', new RegExp('^/session/[^/]+/appium')],
    ['POST', new RegExp('^/session/[^/]+/appium')],
    ['POST', new RegExp('^/session/[^/]+/element/[^/]+/elements?$')],
    ['POST', new RegExp('^/session/[^/]+/elements?$')],
    ['POST', new RegExp('^/session/[^/]+/execute')],
    ['POST', new RegExp('^/session/[^/]+/execute/sync')],
    ['GET', new RegExp('^/session/[^/]+/timeouts$')],
    ['POST', new RegExp('^/session/[^/]+/timeouts$')],
];
class Mac2Driver extends driver_1.BaseDriver {
    constructor(opts = {}) {
        // @ts-ignore TODO: Make opts typed
        super(opts);
        this.macosLaunchApp = appManagemenetCommands.macosLaunchApp;
        this.macosActivateApp = appManagemenetCommands.macosActivateApp;
        this.macosTerminateApp = appManagemenetCommands.macosTerminateApp;
        this.macosQueryAppState = appManagemenetCommands.macosQueryAppState;
        this.macosExecAppleScript = appleScriptCommands.macosExecAppleScript;
        this.execute = executeCommands.execute;
        this.findElOrEls = findCommands.findElOrEls;
        this.macosSetValue = gesturesCommands.macosSetValue;
        this.macosClick = gesturesCommands.macosClick;
        this.macosScroll = gesturesCommands.macosScroll;
        this.macosSwipe = gesturesCommands.macosSwipe;
        this.macosRightClick = gesturesCommands.macosRightClick;
        this.macosHover = gesturesCommands.macosHover;
        this.macosDoubleClick = gesturesCommands.macosDoubleClick;
        this.macosClickAndDrag = gesturesCommands.macosClickAndDrag;
        this.macosClickAndDragAndHold = gesturesCommands.macosClickAndDragAndHold;
        this.macosKeys = gesturesCommands.macosKeys;
        this.macosPressAndHold = gesturesCommands.macosPressAndHold;
        this.macosTap = gesturesCommands.macosTap;
        this.macosDoubleTap = gesturesCommands.macosDoubleTap;
        this.macosPressAndDrag = gesturesCommands.macosPressAndDrag;
        this.macosPressAndDragAndHold = gesturesCommands.macosPressAndDragAndHold;
        this.macosDeepLink = navigationCommands.macosDeepLink;
        this.startRecordingScreen = recordScreenCommands.startRecordingScreen;
        this.stopRecordingScreen = recordScreenCommands.stopRecordingScreen;
        this.macosStartNativeScreenRecording = nativeScreenRecordingCommands.macosStartNativeScreenRecording;
        this.macosGetNativeScreenRecordingInfo = nativeScreenRecordingCommands.macosGetNativeScreenRecordingInfo;
        this.macosStopNativeScreenRecording = nativeScreenRecordingCommands.macosStopNativeScreenRecording;
        this.macosListDisplays = nativeScreenRecordingCommands.macosListDisplays;
        this.macosScreenshots = screenshotCommands.macosScreenshots;
        this.macosSource = sourceCommands.macosSource;
        this.desiredCapConstraints = desired_caps_1.desiredCapConstraints;
        this.locatorStrategies = [
            'id',
            'name',
            'accessibility id',
            'xpath',
            'class name',
            '-ios predicate string',
            'predicate string',
            '-ios class chain',
            'class chain',
        ];
        this.resetState();
        this.settings = new driver_1.DeviceSettings({}, this.onSettingsUpdate.bind(this));
    }
    async onSettingsUpdate(key, value) {
        return await this.wda.proxy.command('/appium/settings', 'POST', {
            settings: { [key]: value }
        });
    }
    resetState() {
        // @ts-ignore This is ok
        this.wda = null;
        this.proxyReqRes = null;
        this.isProxyActive = false;
        this._videoChunksBroadcaster = new nativeScreenRecordingCommands.NativeVideoChunksBroadcaster(this.eventEmitter, this.log);
        this._screenRecorder = null;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    proxyActive(sessionId) {
        return this.isProxyActive;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    getProxyAvoidList(sessionId) {
        return NO_PROXY;
    }
    canProxy() {
        return true;
    }
    async proxyCommand(url, method, body = null) {
        return await this.wda.proxy.command(url, method, body);
    }
    // @ts-ignore We know WDA response should be ok
    async getStatus() {
        return await this.wda.proxy.command('/status', 'GET');
    }
    // needed to make image plugin work
    async getWindowRect() {
        return await this.wda.proxy.command('/window/rect', 'GET');
    }
    // @ts-ignore TODO: make args typed
    async createSession(...args) {
        // @ts-ignore TODO: make args typed
        const [sessionId, caps] = await super.createSession(...args);
        this.wda = wda_mac_1.default;
        try {
            if (caps.prerun) {
                if (!lodash_1.default.isString(caps.prerun.command) && !lodash_1.default.isString(caps.prerun.script)) {
                    throw new Error(`'prerun' capability value must either contain ` +
                        `'script' or 'command' entry of string type`);
                }
                logger_1.default.info('Executing prerun AppleScript');
                const output = await this.macosExecAppleScript(caps.prerun);
                if (lodash_1.default.trim(output)) {
                    logger_1.default.info(`Prerun script output: ${output}`);
                }
            }
            await this.wda.startSession(caps, {
                reqBasePath: this.basePath,
            });
        }
        catch (e) {
            await this.deleteSession();
            throw e;
        }
        this.proxyReqRes = this.wda.proxy.proxyReqRes.bind(this.wda.proxy);
        this.isProxyActive = true;
        return [sessionId, caps];
    }
    async deleteSession() {
        await this._screenRecorder?.stop(true);
        if (this._videoChunksBroadcaster.hasPublishers) {
            try {
                await this.wda.proxy.command('/wda/video/stop', 'POST', {});
            }
            catch { }
            await this._videoChunksBroadcaster.shutdown(5000);
        }
        await this.wda.stopSession();
        if (this.opts.postrun) {
            if (!lodash_1.default.isString(this.opts.postrun.command) && !lodash_1.default.isString(this.opts.postrun.script)) {
                logger_1.default.error(`'postrun' capability value must either contain ` +
                    `'script' or 'command' entry of string type`);
            }
            else {
                logger_1.default.info('Executing postrun AppleScript');
                try {
                    const output = await this.macosExecAppleScript(this.opts.postrun);
                    if (lodash_1.default.trim(output)) {
                        logger_1.default.info(`Postrun script output: ${output}`);
                    }
                }
                catch (e) {
                    logger_1.default.error(e.message);
                }
            }
        }
        this.resetState();
        await super.deleteSession();
    }
}
exports.Mac2Driver = Mac2Driver;
Mac2Driver.newMethodMap = method_map_1.newMethodMap;
Mac2Driver.executeMethodMap = execute_method_map_1.executeMethodMap;
exports.default = Mac2Driver;
//# sourceMappingURL=driver.js.map